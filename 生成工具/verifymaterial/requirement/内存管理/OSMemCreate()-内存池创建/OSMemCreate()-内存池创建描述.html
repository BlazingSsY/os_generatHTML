<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>需求描述</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
            position: relative;
        }
        
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* 返回链接样式1 */
        .back-right-link {
            position: absolute;
            top: 30px;
            right: 40px;
            color: #0066cc;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: white;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .back-right-link:hover {
            color: #004499;
            background-color: #f0f7ff;
            border-color: #0066cc;
            text-decoration: none;
        }

        /* 返回链接样式2 */
        .back-right2-link {
            position: absolute;
            top: 82px;
            right: 40px;
            color: #0066cc;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: white;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .back-right2-link:hover {
            color: #004499;
            background-color: #f0f7ff;
            border-color: #0066cc;
            text-decoration: none;
        }

        /* 返回链接样式3 */
        .back-left-link {
            position: absolute;
            top: 30px;
            left: 40px;
            color: #0066cc;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: white;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .back-left-link:hover {
            color: #004499;
            background-color: #f0f7ff;
            border-color: #0066cc;
            text-decoration: none;
        }
        
        h1 {
              font-size: 28px;
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #3498db;
        }
        
        .text-box {
            background-color: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 25px;
            margin: 0;
            white-space: pre-line;
            font-size: 14px;
            line-height: 1.8;
        }
    </style>
</head>
<body>
          <!-- 返回链接 -->
    <a href="OSMemCreate()-内存池创建.html" class="back-right-link">返回上一级</a>
    <div class="container">
        <h1>需求描述</h1>
        
        <div class="text-box">
<p><strong>需求编号</strong>：HLR_OS_07_01</p><p><strong>工作描述</strong>：HLR：uC/OS-Ⅲ应提供创建内存池的接口</p><p><strong>是否需求</strong>：是</p><p><strong>验证方法</strong>：测试验证</p><p><strong>补充信息</strong>：</p><p>1.函数名称</p><p>OSMemCreate ()---内存池创建函数</p><p>2.函数框架</p><div class="ql-code-block-container" spellcheck="false"><div class="ql-code-block" data-language="plain">void OSMemCreate (</div><div class="ql-code-block" data-language="plain">&nbsp;&nbsp;&nbsp;&nbsp;OS_MEM       *p_mem,    /* 输入：指向内存池控制块的指针 */</div><div class="ql-code-block" data-language="plain">&nbsp;&nbsp;&nbsp;&nbsp;CPU_CHAR     *p_name,   /* 输入：内存池的名称 */</div><div class="ql-code-block" data-language="plain">&nbsp;&nbsp;&nbsp;&nbsp;void         *p_addr,   /* 输入：内存池的起始地址 */</div><div class="ql-code-block" data-language="plain">&nbsp;&nbsp;&nbsp;&nbsp;OS_MEM_QTY    n_blks,   /* 输入：内存池中的块数量 */</div><div class="ql-code-block" data-language="plain">&nbsp;&nbsp;&nbsp;&nbsp;OS_MEM_SIZE   blk_size, /* 输入：每个内存块的大小 */</div><div class="ql-code-block" data-language="plain">&nbsp;&nbsp;&nbsp;&nbsp;OS_ERR       *p_err     /* 输出：错误码指针*/</div><div class="ql-code-block" data-language="plain">)</div></div><p><br></p><p>3.函数描述</p><p>该函数用于创建一个内存池。内存池是一组固定大小的内存块，任务可以从中申请和释放内存块。函数会初始化内存池控制块，并构建内存块的空闲链表。</p><p>4.参数说明</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) p_mem</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型：OS_MEM*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：指向内存池控制块的指针，用于管理内存池。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) p_name</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型：CPU_CHAR*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：内存池的名称，用于调试和跟踪。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) p_addr</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型：void*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：内存池的起始地址，必须是有效的地址且满足对齐要求。</p><p>&nbsp;&nbsp;&nbsp;（4) n_blks</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型：OS_MEM_QTY</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：内存池中的内存块数量，必须至少为 2。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) blk_size</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型：OS_MEM_SIZE</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：每个内存块的大小，必须足够容纳一个指针。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6) p_err</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型：OS_ERR*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：用于返回函数执行的错误代码，指示函数调用是否成功以及失败的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误码：</p><div class="ql-code-block-container" spellcheck="false"><div class="ql-code-block" data-language="plain">OS_ERR_NONE: 成功创建内存池</div><div class="ql-code-block" data-language="plain">OS_ERR_MEM_CREATE_ISR：从中断服务例程调用该函数，这是不允许的。</div><div class="ql-code-block" data-language="plain">OS_ERR_MEM_INVALID_P_ADDR：传入的内存分区起始地址无效或未满足对齐要求。</div><div class="ql-code-block" data-language="plain">OS_ERR_MEM_INVALID_BLKS：内存块数量小于 2。</div><div class="ql-code-block" data-language="plain">OS_ERR_MEM_INVALID_SIZE：内存块大小不足或未满足对齐要求。</div><div class="ql-code-block" data-language="plain">OS_ERR_OBJ_CREATED：内存池控制块已被创建。</div></div><p><br></p><p>5.函数算法逻辑</p><p>(1)检查是否在中断环境中调用</p><p>如果 OS_CFG_CALLED_FROM_ISR_CHK_EN 功能启用，检测当前是否处于中断服务例程（ISR）中。若处于 ISR 中，将错误码 OS_ERR_MEM_CREATE_ISR 存储到 p_err 中，并返回。</p><p><br></p><p>(2)参数检查</p><p>如果 OS_CFG_ARG_CHK_EN 功能启用，则进行以下检查：</p><ol class="bullet"><li class="bullet"><span class="ql-ui" contenteditable="false"></span>检查内存池起始地址的有效性：如果 p_addr 为 NULL ，将错误码 OS_ERR_MEM_INVALID_P_ADDR 存储到 p_err 中，并返回。</li><li class="bullet"><span class="ql-ui" contenteditable="false"></span>检查内存块数量：如果 n_blks 小于 2，将错误码 OS_ERR_MEM_INVALID_BLKS 存储到 p_err 中，并返回。</li><li class="bullet"><span class="ql-ui" contenteditable="false"></span>检查内存块大小有效性：如果 blk_size 小于指针变量所占内存的大小，将错误码 OS_ERR_MEM_INVALID_SIZE 存储到 p_err 中，并返回。</li><li class="bullet"><span class="ql-ui" contenteditable="false"></span>检查内存池起始地址是否满足地址对齐：如果 p_addr 未满足地址对齐要求(为指针变量所占内存的大小的整数倍)，将错误码 OS_ERR_MEM_INVALID_P_ADDR 存储到 p_err 中，并返回</li><li class="bullet"><span class="ql-ui" contenteditable="false"></span>检查内存块大小是否满足地址对齐：如果 blk_size 未满足地址对齐要求(为指针变量所占内存的大小的整数倍)，将错误码 OS_ERR_MEM_INVALID_SIZE 存储到 p_err 中，并返回。</li></ol><p><br></p><p>(3)构建内存块链表</p><p>将内存池的起始地址转换为指针数组的起始地址。</p><p>遍历内存块，为每个内存块设置指向下一个内存块的指针，最后一个内存块的指针设置为 NULL，构建内存块链表。</p><p><br></p><p>(4)检查内存池是否重复创建</p><p>进入临界区，如果启用了对象类型检查（OS_OBJ_TYPE_REQ &gt; 0u）和已创建对象检查（OS_CFG_OBJ_CREATED_CHK_EN &gt; 0u），检查内存池控制块的类型是否已设置为内存池类型。如果是，退出临界区，将错误码 OS_ERR_OBJ_CREATED 存储到 p_err 中，并返回。</p><p><br></p><p>(5)初始化内存池控制块</p><p>将内存池控制块的类型设置为内存池类型（OS_OBJ_TYPE_MEM）。</p><p>将内存池控制块的起始地址设置为 p_addr。</p><p>将空闲链表指针设置为 p_addr。</p><p>将空闲块数量设置为 n_blks。</p><p>将最大块数量设置为 n_blks。</p><p>将每个内存块的大小设置为 blk_size。</p><p><br></p><p>(6)退出临界区并返回</p><p>退出临界区，将错误码 OS_ERR_NONE 存储到 p_err 中</p><p>6.返回值</p><p>无</p><p>5.健康管理错误码&nbsp;</p><p>无</p><p>备注：无</p>
        </div>
    </div>
</body>
</html>